In the following sections we will shortly summarise both syntax and semantics of linear temporal logic in the
propositional form and show the issue of directly translating it to the quantified first-order version.
Since many combinations of both unary and binary operators have been studied as forms of linear temporal logic, we will
investigate only the somewhat common case of a logic with a singular primitive unary operation, \emph{next}, and a
singularo primitive binary operation, \emph{until}. Nonetheless, both the classical approach and the one presented in
this work can be trivially extended with other operators known in the literature, like \emph{unless}.

\section{Syntax}

\begin{definition}[Linear Temporal Logic]
  Let $\text{PROP}$ be a set of atomic propositions. The set $\mathcal{F}$ of formulae for Linear Temporal Logic is the
  set generated by the following grammar:
  \[
    \phi \Coloneqq tt \;|\; p
                      \;|\; \neg\phi
                      \;|\; \phi \lor \phi
                      \;|\; \nextop{\phi}
                      \;|\; \until{\phi}{\phi}
  \]
  where $p \in \text{PROP}$, $X$ is a unary operator which states that $\phi$ must hold at the next step and $U$ is a
  binary operator which states that the first formula must hold until the second formula holds at some point in the
  current or next steps.
\end{definition}

Classical propositional logic connetives can be derived trivially:
\[
  \phi_1 \land \phi_2 \equiv \neg(\neg\phi_1 \lor \neg\phi_2) \qquad
  \phi_1 \to \phi_2 \equiv \neg\phi_1 \lor \phi_2
\]

Other temporal operators used in temporal logic literature are derivable as such:
\[
  \eventually{\phi} \equiv \until{tt}{\phi} \qquad
  \forever{\phi} \equiv \neg\eventually(\neg\phi) \qquad
  \weak{\phi_1}{\phi_2} \equiv (\until{\phi_1}{\phi_2}) \lor \forever{\phi_1}
\]
Intuitively $\eventually{\phi}$ means that eventually at some next step in time the formula $\phi$ holds,
$\forever{\phi}$ means that the formula $\phi$ holds at each possible next step.

\begin{figure}
  \begin{center}
  \begin{tikzpicture}[> = stealth', shorten > = 2pt, shorten < = 2pt, auto, node distance = 2cm, semithick]
    \tikzstyle{vertex} = [circle, draw = black, thick, fill = white, minimum size = 2mm]
    \node[vertex] (0u) [label=$\phi_1$] {};
    \node[vertex] (1u) [right = 1cm of 0u, label=$\phi_1$] {};
    \node[vertex] (2u) [right = 1cm of 1u, label=$\phi_1$] {};
    \node[vertex] (3u) [right = 1cm of 2u, label=$\phi_2$] {};
    \coordinate[right = 1cm of 3u] (4u);
    \node[left = 1cm of 0u] (until) {$\phi_1\;U\,\phi_2$};

    \path[->] (0u) edge [] (1u);
    \path[->, dotted] (1u) edge [] (2u);
    \path[->] (2u) edge [] (3u);
    \path[->, dotted] (3u) edge [] (4u);

    \node[vertex] (0f) [below = 1cm of 0u] {};
    \node[vertex] (1f) [right = 1cm of 0f] {};
    \node[vertex] (2f) [right = 1cm of 1f, label=$\phi$] {};
    \node[vertex] (3f) [right = 1cm of 2f] {};
    \coordinate[right = 1cm of 3f] (4f);
    \node[left = 1cm of 0f] (eventually) {$F\phi$};

    \path[->] (0f) edge [] (1f);
    \path[->, dotted] (1f) edge [] (2f);
    \path[->] (2f) edge [] (3f);
    \path[->, dotted] (3f) edge [] (4f);

    \node[vertex] (0g) [below = 1cm of 0f, label=$\phi$] {};
    \node[vertex] (1g) [right = 1cm of 0g, label=$\phi$] {};
    \node[vertex] (2g) [right = 1cm of 1g, label=$\phi$] {};
    \node[vertex] (3g) [right = 1cm of 2g, label=$\phi$] {};
    \coordinate[right = 1cm of 3g] (4g);
    \node[left = 1cm of 0g] (forever) {$G\phi$};

    \path[->] (0g) edge [] (1g);
    \path[->, dotted] (1g) edge [] (2g);
    \path[->] (2g) edge [] (3g);
    \path[->, dotted] (3g) edge [] (4g);
  \end{tikzpicture}
  \end{center}
  \caption{Example of temporal traces for operators}
\end{figure}

LTL formulae can encode safety properties, commonly with the form $G\neg\phi$, and liveness properties of systems,
commonly with the form $GF\phi$ or $G(\phi_1 \to F\phi_2)$. Let's assume that we have two concurrent processes and that
we can encode with two atomic propositions, $\text{crit}_1$ and $\text{crit}_2$, when the two processes can access a
critical section, then the property of mutual exclusivity can be model by the formula $G(\neg\text{crit}_1 \lor
\neg\text{crit}_2)$. If we also have atomic propositions for wait conditions, $\text{wait}_1$, then we can model
liveness conditions, for example $G(\text{wait}_1 \to F\text{crit}_1)$ which means that whenever a process reaches a
wait condition, eventually will enter the critical section; we can also model fairness conditions, for example
$GF\text{wait}_1 \to GF\text{crit}_1$ means that if the process infinitely often reaches a wait condition than
infinitely often will reach the critical section.

\section{Semantic}

The de-facto standard semantics for Linear Temporal Logic and Temporal Logics in general are Kripke-style semantics, as
for modal logics. In modal logic, the so-called Kripke-frames are pairs of set of worlds and an accessibility relation
between worlds. For temporal logic, each world is a point in time and the accessibility relation models the flow of
time, thus a temporal model is defined as:

\begin{definition}[Temporal model]
  A \emph{temporal model} $M$ is a triple $(T, \prec, L)$ where $T$ is a set of time-points, $\prec$ is an accessibility
  relations over $T$ and $L : T \to \mathcal{P}(\text{PROP})$ is a labelling function that for each point in time
  returns the subset of all atomic propositions which are valid at that point.
\end{definition}

Additionally, the pair $(T, \prec)$ is called a temporal frame.

\begin{definition}[LTL semantic]
  The truthness of a LTL formula $\phi$ at the time-point $t$ over the temporal model $M$, denoted as
  $M, t \vDash \phi$ is defined inductively as follows:
  \begin{align*}
    M, t &\vDash tt && \\
    M, t &\vDash p &&\text{ iff } p \in L(t) \\
    M, t &\vDash \neg\phi &&\text{ iff } M, t \nvDash \phi \\
    M, t &\vDash \phi_1 \lor \phi_2 &&\text{ iff } M, t \vDash \phi_1 \text{ or } M, t \vDash \phi_2 \\
    M, t &\vDash \nextop{\phi} &&\text{ iff } \foralls{t \prec t'}{M, t' \vDash \phi} \\
    M, t &\vDash \until{\phi_1}{\phi_2} &&\text{ iff } M, t \vDash \phi_2 \text{ or } (M, t \vDash \phi_1 \text{ and }
      \foralls{t \prec t'}{M, t' \vDash \until{\phi_1}{\phi_2}})
  \end{align*}
\end{definition}

\section{First-Order Extension}

LTL can be extended to a first-order calculus by introducing predicates and variables, in the same vein as the
transition from propositional to first-order logic in the classical framework. Naturally, because we are additionally
working with time-dependent components, predicate symbols and variables can be interpreted differently at different
point in time. Symbols that are established to be time-dependent are called \emph{flexible}, conversely time-independent
symbols are called \emph{rigid}.

Nonetheless both classical logic and linear temporal logic have in common the trait of becoming indecidable when passing
from propositional calculi to first-order calculi. Furthermore First-Order Linear Temporal Logic is proven to be also
incomplete.

In the following paragraphs we will show a general syntax and semantics of First-Order Linear Temporal Logic, what are
the condition for completeness and some of the issue with the most common semantic.

\begin{definition}[First-Order Linear Temporal Logic]\label{def:kripkefoltlsyn}
  Let $\mathcal{P}$ be a set of predicates each with a specific arity, and let $X$ be a denumerable set of variables.
  The set $\mathcal{F}_{FO}$ of formulae for First-Order Linear Temporal Logic is the set generated by the following grammar:
  \[
    \phi \Coloneqq tt \;|\; P(x_1, \ldots, x_n)
                      \;|\; \neg\phi
                      \;|\; \phi \lor \phi
                      \;|\; \nextop{\phi}
                      \;|\; \until{\phi}{\phi}
                      \;|\; \existss{x}{\phi}
  \]
  where $P \in \mathcal{P}$ and $x_1, \ldots, x_n \in X$ are individual variables that match the arity required by $P$.
\end{definition}
Universal quantification can be modeled with the translation from the existential quantifier and negation:
\[
  \foralls{x}{\phi} \equiv \neg\existss{x}{\neg\phi}
\]

Example of properties can be modeled with the first-order extension are:
\[
  \existss{x}{G(\text{channel}(x) \land \text{open}(x))}
\]
with the intuitive meaning that there must always exists at least one open channel; or:
\[
  \foralls{x}{G(\text{channel}(x) \to (\until{\text{open}(x)}{(\neg\existss{y}{\text{message}(y) \land \text{pending}(x, y)})}))}
\]
which intuitively means that channels must always remain open until there are no more pending messages on that channel.

For quantified LTL we need to extend the temporal frames with the domain of values that makes sense to talk about at
each points in time.

\begin{definition}[Kripke frame]
  A \emph{Kripke frame} $M$ is a quadruple $(T, \prec, D, d)$ where $T$ is a set of time-points, $\prec$ is an
  accessibility relation over $T$, $D$ is a function assigning to each point in time $t$ a non-empty set $D(t)$ s.t.
  if $t \prec t'$ then $D(t) \subseteq D(t')$, $d$ is a function assigning to each point in time $t$ a set $d(t)
  \subseteq D(t)$.
\end{definition}
Intuitively, the so-called outer domains $D(t)$ represent the collection of object that can be referenced at the point
in time $t$, conversely the so-called inner domains $d(t)$ represent the collection of object actually existing the
point in time $t$. An assignement function $\sigma$ is a function from the set of variables $X$ to the outer-domain
$D(t)$ of a given point in time $t$. Finally, we need an interpretation function $I$ such that $I(P, t)$ assign for each
predicate constant $P \in \mathcal{P}$ and point in time $t$ a subset of $D^n(t)$ where $n$ is the arity of $P$, and
$I(x, t) = \sigma(x)$ where $x \in X$ and $\sigma$ is a suitable assignment that is said to be inducing $I$, noted as
$I^\sigma$.

\begin{definition}[FO-LTL semantic]
  The truthness of a FO-LTL formula $\phi$ at the point in time $t$ over the Kripke model $M$ and the induced
  interpretation $I^\sigma$, denoted as $M, t, I^\sigma \vDash \phi$ is defined inductively as follows:
  \begin{align*}
    M, t, I^\sigma &\vDash tt && \\
    M, t, I^\sigma &\vDash P(x_1, \ldots, x_n) &&\text{iff } (\sigma(x_1), \ldots, \sigma(x_2)) \in I^\sigma(P, t) \\
    M, t, I^\sigma &\vDash \neg\phi &&\text{iff } M, t, I^\sigma \nvDash \phi \\
    M, t, I^\sigma &\vDash \phi_1 \lor \phi_2 &&\text{iff } M, t, I^\sigma \vDash \phi_1 \text{ or } M, t, I^\sigma
      \vDash \phi_2 \\
    M, t, I^\sigma &\vDash \nextop{\phi} &&\text{iff } \foralls{t \prec t'}{M, t', I^\sigma \vDash \phi} \\
    M, t, I^\sigma &\vDash \until{\phi_1}{\phi_2} &&\text{iff } M, t, I^\sigma \vDash \phi_2 \text{ or }
      (M, t, I^\sigma \vDash \phi_1 \text{ and } M, t', I^\sigma \vDash \until{\phi_1}{\phi_2}) \\
    M, t, I^\sigma &\vDash \existss{x}{\phi} &&\text{iff } \existss{v \in d(t)}{M, t, I^{\sigma[v/x]} \vDash \phi} \\
  \end{align*}
\end{definition}

\section{Trans-World Identity}

Kripke-frames requires that the so-called outer domains $D(t)$ are always increasing with time, i.e. if $t \prec t'$
then $D(t) \subseteq D(t')$. This condition is required to evaluate temporal operators, otherwise it would not be
possible to denote a variable $x$ in the future. Other works fix a universal domain equal for each point in time, thus
$D(t) = D(t')$ for each $t, t' \in T$, which also follows from accessibility relations that contain loops.
However, by imposing such condition we are identifying object \emph{a priori}
and universally, irrespective of time. This problem is called \emph{trans-world identity} and extensive literature about
it has been produced in the last half-century, be either philosophycal questions or possible pratical solutions with
Kripke-style semantics.

Even with the additional constraints on object domains, there are still other issues with Kripke-style semantics and the
system we are trying to model. Assume we are trying to model resource allocation in a complex system. Let $i$ be a
resource. Due to the outer domain condition, we can identify the exact point in time where the resource $i$ is
allocated, i.e. $i \in D(t)$ for some time point $t$. Note that the resource can be allocated, but still can be unused
for a potentially infinite amount of time, since it may not belong to any inner domain, not even $d(t)$. However, at the
same time, we cannot deallocate the resource $i$ since it must always be referentiable at future point in times. This
can be solved with infinite outer domains to ensure uniqueness or by restricting the class of admissible evolutions, but
such solutions tend to hamper usability.

Another desiderable behaviour is merging, for example while modeling memory allocations, we may want to merge two memory
allocated segments into a single segment and treat it as a single resource.

In the next chapter we will explore an alternative approach based on \emph{counterpart relations}, which rejects the
possibility of universally identifying objects among possible worlds.
