\section{Syntax}

\begin{definition}[First-Order Linear Temporal Logic]
Let $\Sigma$ be a (multi-sorted) signature and $X$ a denumerable set of variables typed over $S_\Sigma$. The set
$\mathcal{F}_\Sigma$ of formulae for First-Order Linear Temporal Logic is the set generated by the following grammar:
\[
  \phi \Coloneqq tt \;|\; \epsilon_\tau = \epsilon_\tau
                    \;|\; \neg\phi
                    \;|\; \phi \lor \phi
                    \;|\; \existss{x_\tau}{\phi}
                    \;|\; \nextop{\phi}
                    \;|\; \until{\phi}{\phi}
\]
where $\epsilon \in \terms{\Sigma}{X}$, $\exists x_\tau$ ranges over variables of sort $\tau \in S_\Sigma$,
$O$ is a unary operator which states that $\phi$ must hold at the next step and $U$ is a binary operator which states
that the first formula must hold until the second formula holds at some point in the current or next steps.
\end{definition}

Classical propositional logic and other temporal operators can be derived as for LTL, with the addition of the trivially
derivable universal quantifier, $\foralls{x_\tau}{\phi} \equiv \neg\existss{x_\tau}{\neg\phi}$. We will also define a
shorthand for inequality, $x_\tau \neq \epsilon_\tau \equiv \neg(x_\tau = \epsilon_\tau)$.

The syntax is almost identical to the one introduced in~\autoref{def:kripkefoltlsyn}, but predicates are replaced by
equality of terms, which we will further specify in the next section, and the existential quantifier is instead a family
of operators indexed by the sorts of the signature.

\begin{example}
  Let's model some general properties that can be resonable in a large space of signatures, as a consequence these will
  really be a family of typed predicates. Let's start with a predicate that identifies entities that will be deleted in
  the next step: $\text{will-be-deleted}(x_\tau) \equiv (\existss{y_\tau}{x = y}) \land \nextop{(\neg\existss{y_\tau}{x =
  y})}$. Another example is $\text{will-merge}(x_\tau, y_\tau) \equiv (\existss{z_\tau}{\existss{w_\tau}{\until{(x \neq
  y \land x = z \land y = w)}{(\existss{z_\tau}{x = y \land x = z \land y = z})}}})$, which intuitively means that the arguments of
  the predicate will necessarily merge into a single entity in the current world or at some point in the future.
  Recall the signature for simple directed graphs introduced in~\autoref{sec:algebra}, we can define predicates on the
  structure of the worlds, e.g. $\text{loop}(x_{\tau_e}) \equiv s(x) = t(x)$ which means that the edge $x$ must be a
  loop in the worlds that satisfy the predicate. We can also model the evolution of complex structures, e.g.
  $\text{at-most-2}_\tau \equiv \foralls{x_\tau}{\foralls{y_\tau}{\foralls{z_\tau}{x = y \lor y = z \lor z = x}}}$ is
  true for worlds where the number of entities of sort $\tau$ is bounded by 2. This predicate can be extended to larger
  boundaries or enforced during the evolution of the system, e.g. assume that the graph signature is used to model a net
  of unidirectional inter-process communication channel, we may want to verify that the number of channel, or edges,
  spawned during the whole execution is bounded by some number $n$ than we must verify the formula
  $\forever{\text{at-most-n}}$; or we may want to make sure that after reaching maximum capacity, the programs
  continously deallocate channels until a minimum bound $m$ is reached, thus $\forever{(\text{at-most-n} \land (\text{exactly-n} \to
  \until{(\existss{x}{\text{will-be-deleted(x)}})}{\text{at-most-m}}))}$, where $\text{exactly-n}$ is a predicate that
  is true when there are exactly $n$ distinct entities of a given sort.
\end{example}
